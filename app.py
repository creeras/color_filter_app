import tkinter as tk
from tkinter import ttk
import numpy as np
from PIL import Image, ImageGrab, ImageTk
import ctypes
from ctypes import windll
import os
import platform

# --- 상수 정의 ---
DEFAULT_GEOMETRY = "300x300+100+100"
PREVIEW_GEOMETRY = "320x380+450+100"
LENS_LUT_PATH = "filters/magenta_lens.cube"

# --- LUT 관련 함수 ---
def load_lut(path):
    """3D LUT (.cube) 파일을 numpy 배열로 로드합니다."""
    try:
        with open(path, "r") as f:
            lines = [l.strip() for l in f.readlines() if not l.startswith("#") and l.strip()]
        
        size_line = next((line for line in lines if line.startswith("LUT_3D_SIZE")), None)
        if not size_line:
            raise ValueError("LUT_3D_SIZE not found in LUT file.")
        size = int(size_line.split()[1])
        
        table = [list(map(float, line.split())) for line in lines if len(line.split()) == 3]
        table = np.array(table, dtype=np.float32)
        
        # LUT 데이터는 R, G, B 순서로 되어 있다고 가정하고, numpy 배열을 (size, size, size, 3) 형태로 만듭니다.
        # 인덱싱 시 RGB 순서를 유지하기 위해 [r, g, b] 순서로 접근할 수 있도록 재구성합니다.
        return table.reshape((size, size, size, 3))
    except (IOError, ValueError) as e:
        print(f"'{path}' LUT 파일을 읽는 중 오류 발생: {e}")
        return None

def generate_magenta_lut(path=LENS_LUT_PATH):
    """현실적인 Green-Free/Magenta 렌즈 효과를 내는 .cube 파일을 생성합니다."""
    os.makedirs(os.path.dirname(path), exist_ok=True)
    size = 33
    with open(path, "w") as f:
        f.write("# Magenta Lens LUT (Green-Free) - Generated by Gemini\n")
        f.write("LUT_3D_SIZE 33\n")
        f.write("DOMAIN_MIN 0.0 0.0 0.0\n")
        f.write("DOMAIN_MAX 1.0 1.0 1.0\n")
        for r in np.linspace(0, 1, size):
            for g in np.linspace(0, 1, size):
                for b in np.linspace(0, 1, size):
                    r_out = r * 1.10 - g * 0.25 + b * 0.05
                    g_out = g * 0.45 + r * 0.05
                    b_out = b * 1.05 - g * 0.10 + r * 0.05
                    f.write(f"{np.clip(r_out,0,1):.6f} {np.clip(g_out,0,1):.6f} {np.clip(b_out,0,1):.6f}\n")

def initialize_lut_files():
    """필요한 LUT 파일이 없으면 생성합니다."""
    if not os.path.exists(LENS_LUT_PATH):
        generate_magenta_lut()

def setup_dpi_awareness():
    """Windows에서 DPI 인식을 설정하여 UI가 선명하게 보이도록 합니다."""
    if platform.system() == "Windows":
        try:
            # Windows 8.1 이상
            ctypes.windll.shcore.SetProcessDpiAwareness(2)
        except (AttributeError, OSError):
            try:
                # 이전 버전의 Windows
                ctypes.windll.user32.SetProcessDPIAware()
            except (AttributeError, OSError):
                print("DPI Awareness 설정을 변경할 수 없습니다.")

class ColorFilterApp:
    def __init__(self, root):
        self.root = root
        self.preview_window = None
        self.control_frame = None
        self.preview_label = None
        self.current_filter_name = tk.StringVar()
        self.filter_options = {}
        self.tint_blend_factor = 0.25
        
        self.setup_main_window()
        self.setup_preview_window()
        self.load_filters()
        self.setup_controls()
        
        self.on_filter_change(self.current_filter_name.get())
        self.update_preview()

    def setup_main_window(self):
        """메인 스코프 창을 설정합니다."""
        self.root.title("Scope")
        self.root.overrideredirect(True)
        self.root.geometry(DEFAULT_GEOMETRY)
        self.root.attributes("-topmost", True)
        
        transparent_color = '#abcdef'
        self.root.config(bg=transparent_color)
        self.root.attributes("-transparentcolor", transparent_color)

        self.canvas = tk.Canvas(self.root, bg=transparent_color, highlightthickness=0)
        self.canvas.pack(fill=tk.BOTH, expand=True)
        self.rect_id = self.canvas.create_rectangle(0, 0, 300, 300, width=5, outline='red')
        
        self.root.bind("<Configure>", self.on_resize_or_move)
        
        # 창 이동 및 크기 조절 관련 변수
        self.resize_border_width = 15
        self.resize_mode = None
        self._offset_x = 0
        self._offset_y = 0
        
        self.canvas.bind("<ButtonPress-1>", self.on_press)
        self.canvas.bind("<B1-Motion>", self.on_drag)
        self.canvas.bind("<Motion>", self.on_motion)
        self.canvas.bind("<ButtonRelease-1>", lambda e: setattr(self, 'resize_mode', None) or self.canvas.config(cursor='fleur'))

    def setup_preview_window(self):
        """필터가 적용된 화면을 보여주는 미리보기 창을 설정합니다."""
        self.preview_window = tk.Toplevel(self.root)
        self.preview_window.title("Preview")
        self.preview_window.geometry(PREVIEW_GEOMETRY)
        self.preview_window.attributes("-topmost", True)
        self.preview_window.protocol("WM_DELETE_WINDOW", self.on_preview_window_close)
        
        self.preview_label = tk.Label(self.preview_window)
        self.preview_label.pack(fill=tk.BOTH, expand=True, side=tk.BOTTOM)

    def load_filters(self):
        """사용 가능한 모든 색상 필터(행렬 및 LUT)를 로드합니다."""
        self.filter_options = {
            "None (필터 없음)": (np.identity(3), None),
            "Lens (Green-Free/Magenta)": (LENS_LUT_PATH, None),
            "Deuteranopia (적녹색약)": (np.array([[0.625, 0.375, 0], [0.7, 0.3, 0], [0, 0.3, 0.7]]), None),
            "Protanopia (적색맹)": (np.array([[0.567, 0.433, 0], [0.558, 0.442, 0], [0, 0.242, 0.758]]), None),
            "Tritanopia (청황색약)": (np.array([[0.95, 0.05, 0], [0, 0.433, 0.567], [0, 0.475, 0.525]]), None),
            "Achromatopsia (전색맹)": (np.array([[0.299, 0.587, 0.114], [0.299, 0.587, 0.114], [0.299, 0.587, 0.114]]), None),
        }

        # LUT 파일 로드
        for key, (path_or_matrix, tint) in self.filter_options.items():
            if isinstance(path_or_matrix, str) and path_or_matrix.endswith(".cube"):
                lut = load_lut(path_or_matrix)
                self.filter_options[key] = (lut if lut is not None else np.identity(3), tint)

        self.current_filter_name.set("Lens (Green-Free/Magenta)")

    def setup_controls(self):
        """미리보기 창에 필터 선택 메뉴와 버튼을 추가합니다."""
        self.control_frame = ttk.Frame(self.preview_window, padding=10)
        self.control_frame.pack(fill=tk.X, side=tk.TOP)
        
        ttk.Label(self.control_frame, text="Filter:").pack(side=tk.LEFT, padx=(0,5))
        filter_menu = ttk.OptionMenu(self.control_frame, self.current_filter_name, self.current_filter_name.get(), *self.filter_options.keys(), command=self.on_filter_change)
        filter_menu.pack(side=tk.LEFT, fill=tk.X, expand=True)
        
        one_to_one_button = ttk.Button(self.control_frame, text="1:1", width=4, command=self.match_preview_size)
        one_to_one_button.pack(side=tk.RIGHT, padx=(5,0))

    # --- Event Handlers ---
    def on_resize_or_move(self, event):
        self.canvas.coords(self.rect_id, 0, 0, event.width, event.height)

    def on_motion(self, event):
        if self.resize_mode: return
        x, y, w, h = event.x, event.y, self.root.winfo_width(), self.root.winfo_height()
        
        on_right = abs(x - w) < self.resize_border_width
        on_bottom = abs(y - h) < self.resize_border_width

        if on_right and on_bottom: self.canvas.config(cursor="bottom_right_corner")
        elif on_right: self.canvas.config(cursor="sb_h_double_arrow")
        elif on_bottom: self.canvas.config(cursor="sb_v_double_arrow")
        else: self.canvas.config(cursor="fleur")

    def on_press(self, event):
        cursor = self.canvas.cget("cursor")
        self.resize_mode = "move" if cursor == "fleur" else cursor
        self._offset_x = event.x
        self._offset_y = event.y

    def on_drag(self, event):
        if self.resize_mode == "move":
            x = self.root.winfo_pointerx() - self._offset_x
            y = self.root.winfo_pointery() - self._offset_y
            self.root.geometry(f"+{x}+{y}")
        else:
            w, h = self.root.winfo_width(), self.root.winfo_height()
            if "h_double_arrow" in self.resize_mode or "corner" in self.resize_mode:
                w += (event.x - self._offset_x)
                self._offset_x = event.x
            if "v_double_arrow" in self.resize_mode or "corner" in self.resize_mode:
                h += (event.y - self._offset_y)
                self._offset_y = event.y
            self.root.geometry(f"{w}x{h}")

    def on_filter_change(self, filter_name):
        self.preview_window.title(f"Preview ({filter_name.split(' ')[0]})")

    def on_preview_window_close(self):
        """미리보기 창이 닫힐 때 앱 전체를 종료합니다."""
        self.root.destroy()

    def match_preview_size(self):
        """미리보기 창 크기를 스코프 창 크기에 맞춥니다."""
        scope_width = self.root.winfo_width()
        scope_height = self.root.winfo_height()
        control_height = self.control_frame.winfo_height()
        self.preview_window.geometry(f"{scope_width}x{scope_height + control_height}")

    # --- Core Logic ---
    def apply_color_filter(self, img):
        """Pillow 이미지를 받아 현재 선택된 필터를 적용합니다."""
        rgb_array = np.array(img, dtype=float)
        filter_or_lut, tint_rgb = self.filter_options[self.current_filter_name.get()]

        if isinstance(filter_or_lut, np.ndarray):
            if filter_or_lut.ndim == 4: # LUT 필터
                size = filter_or_lut.shape[0]
                rgb_float = rgb_array / 255.0
                indices = (rgb_float * (size - 1)).astype(int)
                r, g, b = indices[..., 0], indices[..., 1], indices[..., 2]
                processed_rgb = filter_or_lut[r, g, b] * 255.0
            else: # 행렬 필터
                processed_rgb = np.dot(rgb_array.reshape(-1, 3), filter_or_lut.T).reshape(rgb_array.shape)
        else:
            # 유효하지 않은 필터 데이터 처리
            processed_rgb = rgb_array

        if tint_rgb is not None:
            tint_array = np.array(tint_rgb, dtype=float)
            processed_rgb = (1 - self.tint_blend_factor) * processed_rgb + self.tint_blend_factor * tint_array

        return Image.fromarray(np.clip(processed_rgb, 0, 255).astype(np.uint8))

    def update_preview(self):
        """스코프 영역을 캡처하고 필터를 적용하여 미리보기 창에 업데이트합니다."""
        if not self.root.winfo_exists() or not self.preview_window.winfo_exists():
            return
            
        x, y = self.root.winfo_x(), self.root.winfo_y()
        w, h = self.root.winfo_width(), self.root.winfo_height()

        if w <= 1 or h <= 1:
            self.root.after(30, self.update_preview)
            return

        try:
            img = ImageGrab.grab(bbox=(x, y, x + w, y + h), all_screens=True)
            if img.mode == 'RGBA': img = img.convert('RGB')
            
            filtered_img = self.apply_color_filter(img)
            
            preview_w, preview_h = self.preview_label.winfo_width(), self.preview_label.winfo_height()
            if preview_w > 1 and preview_h > 1:
                img_resized = filtered_img.resize((preview_w, preview_h), Image.NEAREST)
                photo = ImageTk.PhotoImage(image=img_resized)
                self.preview_label.config(image=photo)
                self.preview_label.image = photo
        except OSError as e:
            # 예: 화면 보호기 활성화, 원격 데스크톱 연결 등 화면 캡처가 불가능한 경우
            print(f"화면 캡처 오류: {e}")
            pass 
        
        self.root.after(30, self.update_preview)

def main():
    """애플리케이션의 메인 진입점입니다."""
    initialize_lut_files()
    setup_dpi_awareness()
    
    root = tk.Tk()
    app = ColorFilterApp(root)
    root.mainloop()

if __name__ == "__main__":
    main()
